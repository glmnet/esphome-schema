{
  "modbus_controller": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "is_list": true,
        "schema": {
          "config_vars": {
            "address": {
              "data_type": "hex_uint8_t",
              "default": "1",
              "docs": "**, [ID](https://esphome.io/guides/configuration-types.html#config-id)**: The Modbus address of the slave device.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "allow_duplicate_commands": {
              "default": "False",
              "docs": "**, boolean**: Whether to allow duplicate commands in the queue. Defaults to `false`.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "boolean"
            },
            "command_throttle": {
              "default": "0ms",
              "docs": "**, [Time](https://esphome.io/guides/configuration-types.html#config-time)**: minimum time in between 2 requests to the device. Default is `0ms`. Some Modbus slave devices limit the rate of requests from the master, so this allows the interval between requests to be altered.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "schema": {
                "extends": [
                  "core.positive_time_period_milliseconds"
                ]
              },
              "type": "schema"
            },
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusController",
                "parents": [
                  "Component",
                  "PollingComponent",
                  "modbus::ModbusDevice"
                ]
              },
              "key": "GeneratedID"
            },
            "max_cmd_retries": {
              "data_type": "positive_int",
              "default": "4",
              "docs": "**, integer**: How many times a command will be retried if no response is received. It doesn\u2019t include the initial transmition. Defaults to 4.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "modbus_id": {
              "docs": "**, [ID](https://esphome.io/guides/configuration-types.html#config-id)**: Manually specify the ID of the `modbus` hub.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "GeneratedID",
              "type": "use_id",
              "use_id_type": "modbus::Modbus"
            },
            "offline_skip_updates": {
              "data_type": "positive_int",
              "default": "0",
              "docs": "**, integer**: When a slave doesn\u2019t respond to a command, it is marked as offline, you can specify how many updates will be skipped while it is offline. If using a bus with multiple slaves, this avoids waiting for timeouts allowing to read other slaves in the same bus. When the slave responds to a command, it\u2019ll be marked online again.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "on_command_sent": {
              "docs": "**, [Automation](https://esphome.io/automations/index.html#automation)**: An automation to perform when a modbus command has been sent. See [on_command_sent](https://esphome.io/components/modbus_controller.html#modbus-controller-on-command-sent)\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "trigger"
            },
            "on_offline": {
              "docs": "**, [Automation](https://esphome.io/automations/index.html#automation)**: An automation to perform when a modbus controller goes offline. See [on_offline](https://esphome.io/components/modbus_controller.html#modbus-controller-on-offline)\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "trigger"
            },
            "on_online": {
              "docs": "**, [Automation](https://esphome.io/automations/index.html#automation)**: An automation to perform when a modbus controller goes online. See [on_online](https://esphome.io/components/modbus_controller.html#modbus-controller-on-online)\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "trigger"
            },
            "server_registers": {
              "docs": "A list of registers that are responded to when acting as a server. - **address** (**Required**, integer): start address of the first register in a range - **value_type** (*Optional*): datatype of the mod_bus register data. The default data type for ModBUS is a 16 bit integer in big endian format (MSB first)\n  * `U_WORD`: unsigned 16 bit integer from 1 register = 16bit\n  \n  * `S_WORD`: signed 16 bit integer from 1 register = 16bit\n  \n  * `U_DWORD`: unsigned 32 bit integer from 2 registers = 32bit\n  \n  * `S_DWORD`: signed 32 bit integer from 2 registers = 32bit\n  \n  * `U_DWORD_R`: unsigned 32 bit integer from 2 registers low word first\n  \n  * `S_DWORD_R`: signed 32 bit integer from 2 registers low word first\n  \n  * `U_QWORD`: unsigned 64 bit integer from 4 registers = 64bit\n  \n  * `S_QWORD`: signed 64 bit integer from 4 registers = 64bit\n  \n  * `U_QWORD_R`: unsigned 64 bit integer from 4 registers low word first\n  \n  * `S_QWORD_R`: signed 64 bit integer from 4 registers low word first\n  \n  * `FP32`: 32 bit IEEE 754 floating point from 2 registers\n  \n  * `FP32_R`: 32 bit IEEE 754 floating point - same as FP32 but low word first\n  \n  Defaults to `U_WORD`.\n  * **read_lambda** (**Required**, [lambda](https://esphome.io/automations/templates.html#config-lambda)): Lambda that returns the value of this register.\n  \n  \n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "is_list": true,
              "key": "Optional",
              "schema": {
                "config_vars": {
                  "address": {
                    "data_type": "positive_int",
                    "key": "Required",
                    "type": "integer"
                  },
                  "id": {
                    "id_type": {
                      "class": "modbus_controller::ServerRegister",
                      "parents": []
                    },
                    "key": "GeneratedID"
                  },
                  "read_lambda": {
                    "docs": "**, [lambda](https://esphome.io/automations/templates.html#config-lambda)**: Lambda that returns the value of this register.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
                    "key": "Required"
                  },
                  "value_type": {
                    "default": "U_WORD",
                    "key": "Optional",
                    "type": "enum",
                    "values": {
                      "FP32": null,
                      "FP32_R": null,
                      "RAW": null,
                      "S_DWORD": null,
                      "S_DWORD_R": null,
                      "S_QWORD": null,
                      "S_QWORD_R": null,
                      "S_WORD": null,
                      "U_DWORD": null,
                      "U_DWORD_R": null,
                      "U_QWORD": null,
                      "U_QWORD_R": null,
                      "U_WORD": null
                    }
                  }
                }
              },
              "type": "schema"
            },
            "update_interval": {
              "default": "60s",
              "docs": "**, [Time](https://esphome.io/guides/configuration-types.html#config-time)**: The interval that the sensors should be checked. Defaults to 60 seconds.\n\n*See also: [Modbus Controller](https://esphome.io/components/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA"
          ]
        },
        "type": "schema"
      },
      "ModbusItemBaseSchema": {
        "schema": {
          "config_vars": {
            "address": {
              "data_type": "positive_int",
              "docs": "**, int**: start address of the first register in a range (can be decimal or hexadecimal).\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "bitmask": {
              "data_type": "hex_uint32_t",
              "default": "4294967295",
              "docs": "**, int**: sometimes multiple values are packed in a single register\u2019s response. The bitmask can be used to extract a value from the response. See [Bitmasks](https://esphome.io/components/modbus_controller.html#bitmasks).\n\n*See also: [Modbus Controller Sensor](https://esphome.io/components/sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "byte_offset": {
              "data_type": "positive_int",
              "key": "Optional",
              "type": "integer"
            },
            "custom_command": {
              "data_type": "hex_uint8_t",
              "docs": "**, list of bytes**: raw bytes for modbus command. This allows using non-standard commands. If `custom_command` is used `address` and `register_type` can\u2019t be used. custom command must contain all required bytes including the modbus device address. The crc is automatically calculated and appended to the command. See [Using custom_command](https://esphome.io/components/modbus_controller.html#modbus-custom-command) how to use `custom_command`\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "is_list": true,
              "key": "Optional"
            },
            "force_new_range": {
              "default": "False",
              "docs": "**, boolean**: If possible sensors with sequential addresses are grouped together and requested in one range. Setting `force_new_range: true` enforces the start of a new range at that address.\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "boolean"
            },
            "lambda": {
              "docs": "**, [lambda](https://esphome.io/automations/templates.html#config-lambda)**: Lambda to be evaluated every update interval to get the new value of the sensor. It is called after the encoding according to **raw_encode**.Parameters passed into the lambda\n  * **x** (std:string): The parsed value of the modbus data according to **raw_encode**\n  \n  * **data** (std::vector<uint8_t>): vector containing the complete raw modbus response bytes for this sensor *note:* because the response contains data for all registers in the same range you have to use `data[item->offset]` to get the first response byte for your sensor.\n  \n  * **item** (const pointer to a SensorItem derived object):  The sensor object itself.\n  \n  Possible return values for the lambda:\n  * `return <std::string>;` the new value for the sensor.\n  \n  * `return {};` uses the parsed value for the state (same as `return x;`).\n  \n  \n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "modbus_controller_id": {
              "key": "GeneratedID",
              "type": "use_id",
              "use_id_type": "modbus_controller::ModbusController"
            },
            "offset": {
              "data_type": "positive_int",
              "docs": "**, int**: Offset from start address in bytes (only required for uncommon response encodings). If more than one register is written in a command this value is used to find the start of this datapoint relative to start address. The component calculates the size of the range based on offset and size of the value type. The value for offset depends on the register type.\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "response_size": {
              "data_type": "positive_int",
              "default": "0",
              "docs": "**, int**: Size of the response for the register in bytes. Defaults to register_count*2.\n\n*See also: [Modbus Controller Sensor](https://esphome.io/components/sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "skip_updates": {
              "data_type": "positive_int",
              "default": "0",
              "docs": "**, int**: By default all sensors of a modbus_controller are updated together. For data points that don\u2019t change very frequently updates can be skipped. A value of 5 would only update this sensor range in every 5th update cycle\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            }
          }
        },
        "type": "schema"
      }
    }
  },
  "modbus_controller.binary_sensor": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "schema": {
          "config_vars": {
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusBinarySensor",
                "parents": [
                  "Component",
                  "EntityBase",
                  "binary_sensor::BinarySensor",
                  "modbus_controller::SensorItem"
                ]
              }
            },
            "register_type": {
              "docs": "type of the modbus register.\n  * `coil`: Coils are 1-bit registers (ON/OFF values) that are used to control discrete outputs. Read and Write access. Modbus *Function Code 1 (Read Coil Status)* will be used.\n  \n  * `discrete_input`: discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used.\n  \n  * `holding`: Holding Registers - Holding registers are the most universal 16-bit register. Read and Write access. Modbus *Function Code 3 (Read Holding Registers)* will be used.\n  \n  * `read`: Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used.\n  \n  \n\n*See also: [Modbus Controller Binary Sensor](https://esphome.io/components/binary_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "coil": {
                  "docs": "Coils are 1-bit registers (ON/OFF values) that are used to control discrete outputs. Read and Write access. Modbus *Function Code 1 (Read Coil Status)* will be used."
                },
                "custom": null,
                "discrete_input": {
                  "docs": "discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used."
                },
                "holding": {
                  "docs": "Holding Registers - Holding registers are the most universal 16-bit register. Read and Write access. Modbus *Function Code 3 (Read Holding Registers)* will be used."
                },
                "read": {
                  "docs": "Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used."
                }
              }
            }
          },
          "extends": [
            "binary_sensor.BINARY_SENSOR_SCHEMA",
            "core.COMPONENT_SCHEMA",
            "modbus_controller.ModbusItemBaseSchema"
          ]
        },
        "type": "schema"
      }
    }
  },
  "modbus_controller.number": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "schema": {
          "config_vars": {
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusNumber",
                "parents": [
                  "Component",
                  "EntityBase",
                  "modbus_controller::SensorItem",
                  "number::Number"
                ]
              },
              "key": "GeneratedID"
            },
            "max_value": {
              "default": "16777215.0",
              "docs": "**, float**: The maximum value this number can be.\n\n*See also: [Modbus Controller Number](https://esphome.io/components/number/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "min_value": {
              "default": "-16777215.0",
              "docs": "**, float**: The minimum value this number can be.\n\n*See also: [Modbus Controller Number](https://esphome.io/components/number/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "multiply": {
              "default": "1.0",
              "docs": "**, float**: multiply the new value with this factor before sending the requests. Ignored if lambda is defined.\n\n*See also: [Modbus Controller Number](https://esphome.io/components/number/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "register_type": {
              "default": "holding",
              "key": "Optional",
              "type": "enum",
              "values": {
                "coil": null,
                "custom": null,
                "holding": null
              }
            },
            "step": {
              "data_type": "positive_float",
              "default": "1",
              "docs": "**, float**: The granularity with which the number can be set. Defaults to 1.\n\n*See also: [Modbus Controller Number](https://esphome.io/components/number/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "use_write_multiple": {
              "default": "False",
              "docs": "**, boolean**: By default the modbus command *Function Code 6 (Preset Single Registers)* is used for setting the holding register if only one register is set. If your device only supports *Function Code 16 (Preset Multiple Registers)* set this option to `true`.\n\n*See also: [Modbus Controller Number](https://esphome.io/components/number/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "boolean"
            },
            "value_type": {
              "default": "U_WORD",
              "docs": "datatype of the modbus register data. The default data type for modbus is a 16 bit integer in big endian format (MSB first):\n  * `U_WORD` (unsigned 16 bit integer from 1 register = 16bit)\n  \n  * `S_WORD` (signed 16 bit integer from 1 register = 16bit)\n  \n  * `U_DWORD` (unsigned 32 bit integer from 2 registers = 32bit)\n  \n  * `S_DWORD` (signed 32 bit integer from 2 registers = 32bit)\n  \n  * `U_DWORD_R` (unsigned 32 bit integer from 2 registers low word first)\n  \n  * `S_DWORD_R` (signed 32 bit integer from 2 registers low word first)\n  \n  * `U_QWORD` (unsigned 64 bit integer from 4 registers = 64bit)\n  \n  * `S_QWORD` (signed 64 bit integer from 4 registers = 64bit)\n  \n  * `U_QWORD_R` (unsigned 64 bit integer from 4 registers low word first)\n  \n  * `S_QWORD_R` (signed 64 bit integer from 4 registers low word first)\n  \n  * `FP32` (32 bit IEEE 754 floating point from 2 registers)\n  \n  * `FP32_R` (32 bit IEEE 754 floating point - same as FP32 but low word first)\n  \n  \n\n*See also: [Modbus Controller Number](https://esphome.io/components/number/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "FP32": null,
                "FP32_R": null,
                "RAW": null,
                "S_DWORD": null,
                "S_DWORD_R": null,
                "S_QWORD": null,
                "S_QWORD_R": null,
                "S_WORD": null,
                "U_DWORD": null,
                "U_DWORD_R": null,
                "U_QWORD": null,
                "U_QWORD_R": null,
                "U_WORD": null
              }
            },
            "write_lambda": {
              "key": "Optional"
            }
          },
          "extends": [
            "modbus_controller.ModbusItemBaseSchema",
            "number.NUMBER_SCHEMA"
          ]
        },
        "type": "schema"
      }
    }
  },
  "modbus_controller.output": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "docs": "Write Coil - Write the ON/OFF status of a discrete coil in the device with *Function Code 5 or 15*. This will create a binary output.\n  \n  * `holding`: Write Holding Registers - write contents of holding registers in the device with *Function Code 6 or 16*. This will create a float output.\n  \n  \n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
        "type": "typed",
        "typed_key": "register_type",
        "types": {
          "coil": {
            "config_vars": {
              "id": {
                "docs": "**, [ID](https://esphome.io/guides/configuration-types.html#config-id)**: Manually specify the ID used for code generation.\n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "id_type": {
                  "class": "modbus_controller::ModbusBinaryOutput",
                  "parents": [
                    "Component",
                    "modbus_controller::SensorItem",
                    "output::BinaryOutput"
                  ]
                },
                "key": "GeneratedID"
              },
              "use_write_multiple": {
                "default": "False",
                "docs": "**, boolean**: By default the modbus command *Function Code 6 (Preset Single Registers)* is used for setting the holding register if only one register is set. If your device only supports *Function Code 16 (Preset Multiple Registers)* set this option to `true`.\n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "key": "Optional",
                "type": "boolean"
              },
              "write_lambda": {
                "docs": "**, [lambda](https://esphome.io/automations/templates.html#config-lambda)**: Lambda is evaluated before the modbus write command is created. The value is passed in as `float x` and an empty vector is passed in as `std::vector<uint16_t>&payload`. You can directly define the payload by adding data to payload then the return value is ignored and the content of payload is used.Parameters passed into the lambda\n  * **x** (float or bool): The float value to be sent to the modbus device for `register_type: holding` or the boolean value to be sent to the modbus device for `register_type: coil`\n  \n  * **payload** (``std::vector<uint16_t>&payload``):\n    * for `register_type: holding`: empty vector for the payload. The lamdba can add 16 bit raw modbus register words.\n    \n    * for `register_type: coil`: empty vector for the payload. If payload is set in the lambda it is sent as a custom command and must include all required bytes for a modbus request note: because the response contains data for all registers in the same range you have to use `data[item->offset]` to get the first response byte for your sensor.\n    \n    \n  \n  * **item** (const pointer to a SensorItem derived object):  The sensor object itself.\n  \n  Possible return values for the lambda:\n  * `return <FLOATING_POINT_NUMBER / BOOL>;` the new value for the sensor.\n  \n  * `return <anything>; and fill payload with data` if the payload is added from the lambda then these 16 bit words will be sent\n  \n  * `return {};` if you don\u2019t want write the command to the device (or do it from the lambda).\n  \n  \n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "key": "Optional"
              }
            },
            "extends": [
              "modbus_controller.ModbusItemBaseSchema",
              "output.BINARY_OUTPUT_SCHEMA"
            ]
          },
          "holding": {
            "config_vars": {
              "id": {
                "docs": "**, [ID](https://esphome.io/guides/configuration-types.html#config-id)**: Manually specify the ID used for code generation.\n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "id_type": {
                  "class": "modbus_controller::ModbusFloatOutput",
                  "parents": [
                    "Component",
                    "modbus_controller::SensorItem",
                    "output::BinaryOutput",
                    "output::FloatOutput"
                  ]
                },
                "key": "GeneratedID"
              },
              "multiply": {
                "default": "1.0",
                "docs": "**, float**: multiply the incoming value with this factor before writing it to the device. Ignored if `write_lambda` is defined. Only valid for `register_type: holding`.\n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "key": "Optional"
              },
              "use_write_multiple": {
                "default": "False",
                "docs": "**, boolean**: By default the modbus command *Function Code 6 (Preset Single Registers)* is used for setting the holding register if only one register is set. If your device only supports *Function Code 16 (Preset Multiple Registers)* set this option to `true`.\n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "key": "Optional",
                "type": "boolean"
              },
              "value_type": {
                "default": "U_WORD",
                "docs": "data type of the modbus register data. The default data type for modbus is a 16 bit integer in big endian format (MSB first).\n  * `U_WORD` (unsigned 16 bit integer from 1 register = 16bit)\n  \n  * `S_WORD` (signed 16 bit integer from 1 register = 16bit)\n  \n  * `U_DWORD` (unsigned 32 bit integer from 2 registers = 32bit)\n  \n  * `S_DWORD` (signed 32 bit integer from 2 registers = 32bit)\n  \n  * `U_DWORD_R` (unsigned 32 bit integer from 2 registers low word first)\n  \n  * `S_DWORD_R` (signed 32 bit integer from 2 registers low word first)\n  \n  * `U_QWORD` (unsigned 64 bit integer from 4 registers = 64bit)\n  \n  * `S_QWORD` (signed 64 bit integer from 4 registers = 64bit)\n  \n  * `U_QWORD_R` (unsigned 64 bit integer from 4 registers low word first)\n  \n  * `S_QWORD_R` signed 64 bit integer from 4 registers low word first)\n  \n  * `FP32` (32 bit IEEE 754 floating point from 2 registers)\n  \n  * `FP32_R` (32 bit IEEE 754 floating point - same as FP32 but low word first)\n  \n  \n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "key": "Optional",
                "type": "enum",
                "values": {
                  "FP32": null,
                  "FP32_R": null,
                  "RAW": null,
                  "S_DWORD": null,
                  "S_DWORD_R": null,
                  "S_QWORD": null,
                  "S_QWORD_R": null,
                  "S_WORD": null,
                  "U_DWORD": null,
                  "U_DWORD_R": null,
                  "U_QWORD": null,
                  "U_QWORD_R": null,
                  "U_WORD": null
                }
              },
              "write_lambda": {
                "docs": "**, [lambda](https://esphome.io/automations/templates.html#config-lambda)**: Lambda is evaluated before the modbus write command is created. The value is passed in as `float x` and an empty vector is passed in as `std::vector<uint16_t>&payload`. You can directly define the payload by adding data to payload then the return value is ignored and the content of payload is used.Parameters passed into the lambda\n  * **x** (float or bool): The float value to be sent to the modbus device for `register_type: holding` or the boolean value to be sent to the modbus device for `register_type: coil`\n  \n  * **payload** (``std::vector<uint16_t>&payload``):\n    * for `register_type: holding`: empty vector for the payload. The lamdba can add 16 bit raw modbus register words.\n    \n    * for `register_type: coil`: empty vector for the payload. If payload is set in the lambda it is sent as a custom command and must include all required bytes for a modbus request note: because the response contains data for all registers in the same range you have to use `data[item->offset]` to get the first response byte for your sensor.\n    \n    \n  \n  * **item** (const pointer to a SensorItem derived object):  The sensor object itself.\n  \n  Possible return values for the lambda:\n  * `return <FLOATING_POINT_NUMBER / BOOL>;` the new value for the sensor.\n  \n  * `return <anything>; and fill payload with data` if the payload is added from the lambda then these 16 bit words will be sent\n  \n  * `return {};` if you don\u2019t want write the command to the device (or do it from the lambda).\n  \n  \n\n*See also: [Modbus Controller Output](https://esphome.io/components/output/modbus_controller.html#configuration-variables)*",
                "key": "Optional"
              }
            },
            "extends": [
              "modbus_controller.ModbusItemBaseSchema",
              "output.FLOAT_OUTPUT_SCHEMA"
            ]
          }
        }
      }
    }
  },
  "modbus_controller.select": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "schema": {
          "config_vars": {
            "address": {
              "data_type": "positive_int",
              "docs": "**, int**: The start address of the first or only register of the Select  (can be decimal or hexadecimal).\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Required",
              "type": "integer"
            },
            "force_new_range": {
              "default": "False",
              "docs": "**, boolean**: If possible sensors with sequential addresses are grouped together and requested in one range. Setting this to `true` enforces the start of a new range at that address.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "boolean"
            },
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusSelect",
                "parents": [
                  "Component",
                  "EntityBase",
                  "modbus_controller::SensorItem",
                  "select::Select"
                ]
              }
            },
            "lambda": {
              "docs": "**, [lambda](https://esphome.io/automations/templates.html#config-lambda)**: Lambda to be evaluated every update interval to get the current option of the select.Parameters passed into lambda\n  * **x** (`int64_t`): The parsed integer value of the modbus data.\n  \n  * **data** (`const std::vector<uint8_t>&`): vector containing the complete raw modbus response bytes for this sensor. Note: because the response contains data for all registers in the same range you have to use `data[item->offset]` to get the first response byte for your sensor.\n  \n  * **item** (`ModbusSelect*const`):  The sensor object itself.\n  \n  Possible return values for the lambda:\n  * `return <std::string>;` The new option for this Select.\n  \n  * `return {};` Use default mapping (see `optionsmap`).\n  \n  \n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            },
            "modbus_controller_id": {
              "key": "GeneratedID",
              "type": "use_id",
              "use_id_type": "modbus_controller::ModbusController"
            },
            "optimistic": {
              "default": "False",
              "docs": "**, boolean**: Whether to operate in optimistic mode - when in this mode, any command sent to the Modbus Select will immediately update the reported state. Defaults to `false`.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "boolean"
            },
            "optionsmap": {
              "docs": "**, Map[str, int]**: Provide a mapping from options (str) of this Select to values (int) of the modbus register and vice versa. All options and all values have to be unique.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Required"
            },
            "register_count": {
              "data_type": "positive_int",
              "docs": "**, int**: The number of consecutive registers this read request should span or skip in a single command. Default is 1. See [Optimizing modbus communications](https://esphome.io/components/modbus_controller.html#modbus-register-count) for more details.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "skip_updates": {
              "data_type": "positive_int",
              "default": "0",
              "docs": "**, int**: By default, all sensors of a modbus_controller are updated together. For data points that don\u2019t change very frequently, updates can be skipped. A value of 5 would only update this sensor range in every 5th update cycle. Note: The modbus_controller groups components by address ranges to reduce number of transactions. All components with the same starting address will be updated in one request. `skip_updates` applies for *all* components in the same range.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "use_write_multiple": {
              "default": "False",
              "docs": "**, boolean**: By default the modbus command *Function Code 6 (Preset Single Registers)* is used for setting the holding register if only one register is set. If your device only supports *Function Code 16 (Preset Multiple Registers)* set this option to `true`.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "boolean"
            },
            "value_type": {
              "default": "U_WORD",
              "docs": "The datatype of the modbus data. Defaults to `U_WORD`.\n  * `U_WORD` (unsigned 16 bit integer from 1 register = 16bit)\n  \n  * `S_WORD` (signed 16 bit integer from 1 register = 16bit)\n  \n  * `U_DWORD` (unsigned 32 bit integer from 2 registers = 32bit)\n  \n  * `S_DWORD` (signed 32 bit integer from 2 registers = 32bit)\n  \n  * `U_DWORD_R` (unsigned 32 bit integer from 2 registers low word first)\n  \n  * `S_DWORD_R` (signed 32 bit integer from 2 registers low word first)\n  \n  * `U_QWORD` (unsigned 64 bit integer from 4 registers = 64bit)\n  \n  * `S_QWORD` (signed 64 bit integer from 4 registers = 64bit)\n  \n  * `U_QWORD_R` (unsigned 64 bit integer from 4 registers low word first)\n  \n  * `U_QWORD_R` (signed 64 bit integer from 4 registers low word first)\n  \n  \n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "RAW": null,
                "S_DWORD": null,
                "S_DWORD_R": null,
                "S_QWORD": null,
                "S_QWORD_R": null,
                "S_WORD": null,
                "U_DWORD": null,
                "U_DWORD_R": null,
                "U_QWORD": null,
                "U_QWORD_R": null,
                "U_WORD": null
              }
            },
            "write_lambda": {
              "docs": "**, [lambda](https://esphome.io/automations/templates.html#config-lambda)**: Lambda to be evaluated on every update of the Sensor, before the new value is written to the modbus registers.\n\n*See also: [Modbus Controller Select](https://esphome.io/components/select/modbus_controller.html#configuration-variables)*",
              "key": "Optional"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA",
            "select.SELECT_SCHEMA"
          ]
        },
        "type": "schema"
      }
    }
  },
  "modbus_controller.sensor": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "schema": {
          "config_vars": {
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusSensor",
                "parents": [
                  "Component",
                  "EntityBase",
                  "modbus_controller::SensorItem",
                  "sensor::Sensor"
                ]
              }
            },
            "register_count": {
              "data_type": "positive_int",
              "default": "0",
              "docs": "**, int**: The number of consecutive registers this read request should span or skip in a single command. Default is 1. See [Optimizing modbus communications](https://esphome.io/components/modbus_controller.html#modbus-register-count) for more details.\n\n*See also: [Modbus Controller Sensor](https://esphome.io/components/sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "register_type": {
              "docs": "type of the modbus register.\n  * `coil`: Coils are 1-bit registers (ON/OFF values) that are used to control discrete outputs. They may be read and/or written. Modbus *Function Code 1 (Read Coil Status)* will be used.\n  \n  * `discrete_input`: discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used.\n  \n  * `holding`: Holding Registers - Holding registers are the most universal 16-bit register. They may be read and/or written. Modbus *Function Code 3 (Read Holding Registers)* will be used.\n  \n  * `read`: Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used.\n  \n  \n\n*See also: [Modbus Controller Sensor](https://esphome.io/components/sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "coil": {
                  "docs": "Coils are 1-bit registers (ON/OFF values) that are used to control discrete outputs. They may be read and/or written. Modbus *Function Code 1 (Read Coil Status)* will be used."
                },
                "custom": null,
                "discrete_input": {
                  "docs": "discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used."
                },
                "holding": {
                  "docs": "Holding Registers - Holding registers are the most universal 16-bit register. They may be read and/or written. Modbus *Function Code 3 (Read Holding Registers)* will be used."
                },
                "read": {
                  "docs": "Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used."
                }
              }
            },
            "value_type": {
              "default": "U_WORD",
              "docs": "data type of the modbus register data. The default data type for modbus is a 16 bit integer in big endian format (MSB first).\n  * `U_WORD`: unsigned 16 bit integer from 1 register = 16bit\n  \n  * `S_WORD`: signed 16 bit integer from 1 register = 16bit\n  \n  * `U_DWORD`: unsigned 32 bit integer from 2 registers = 32bit\n  \n  * `S_DWORD`: signed 32 bit integer from 2 registers = 32bit\n  \n  * `U_DWORD_R`: unsigned 32 bit integer from 2 registers low word first\n  \n  * `S_DWORD_R`: signed 32 bit integer from 2 registers low word first\n  \n  * `U_QWORD`: unsigned 64 bit integer from 4 registers = 64bit\n  \n  * `S_QWORD`: signed 64 bit integer from 4 registers = 64bit\n  \n  * `U_QWORD_R`: unsigned 64 bit integer from 4 registers low word first\n  \n  * `S_QWORD_R`: signed 64 bit integer from 4 registers low word first\n  \n  * `FP32`: 32 bit IEEE 754 floating point from 2 registers\n  \n  * `FP32_R`: 32 bit IEEE 754 floating point - same as FP32 but low word first\n  \n  \n\n*See also: [Modbus Controller Sensor](https://esphome.io/components/sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "FP32": {
                  "docs": "32 bit IEEE 754 floating point from 2 registers"
                },
                "FP32_R": {
                  "docs": "32 bit IEEE 754 floating point - same as FP32 but low word first"
                },
                "RAW": null,
                "S_DWORD": {
                  "docs": "signed 32 bit integer from 2 registers = 32bit"
                },
                "S_DWORD_R": {
                  "docs": "signed 32 bit integer from 2 registers low word first"
                },
                "S_QWORD": {
                  "docs": "signed 64 bit integer from 4 registers = 64bit"
                },
                "S_QWORD_R": {
                  "docs": "signed 64 bit integer from 4 registers low word first"
                },
                "S_WORD": {
                  "docs": "signed 16 bit integer from 1 register = 16bit"
                },
                "U_DWORD": {
                  "docs": "unsigned 32 bit integer from 2 registers = 32bit"
                },
                "U_DWORD_R": {
                  "docs": "unsigned 32 bit integer from 2 registers low word first"
                },
                "U_QWORD": {
                  "docs": "unsigned 64 bit integer from 4 registers = 64bit"
                },
                "U_QWORD_R": {
                  "docs": "unsigned 64 bit integer from 4 registers low word first"
                },
                "U_WORD": {
                  "docs": "unsigned 16 bit integer from 1 register = 16bit"
                }
              }
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA",
            "modbus_controller.ModbusItemBaseSchema",
            "sensor.SENSOR_SCHEMA"
          ]
        },
        "type": "schema"
      }
    }
  },
  "modbus_controller.switch": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "schema": {
          "config_vars": {
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusSwitch",
                "parents": [
                  "Component",
                  "EntityBase",
                  "modbus_controller::SensorItem",
                  "switch_::Switch"
                ]
              },
              "key": "GeneratedID"
            },
            "register_type": {
              "docs": "type of the modbus register.\n  * `coil`: Coils are 1-bit registers (on/off values) that are used to control discrete outputs. They may be read and/or written. Modbus *Function Code 1 (Read Coil Status)* will be used.\n  \n  * `discrete_input`: discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used.\n  \n  * `holding`: Holding Registers - Holding registers are the most universal 16-bit register. They may be read and/or written. Modbus *Function Code 3 (Read Holding Registers)* will be used.\n  \n  * `read`: Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used.\n  \n  \n\n*See also: [Modbus Controller Switch](https://esphome.io/components/switch/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "coil": {
                  "docs": "Coils are 1-bit registers (on/off values) that are used to control discrete outputs. They may be read and/or written. Modbus *Function Code 1 (Read Coil Status)* will be used."
                },
                "custom": null,
                "discrete_input": {
                  "docs": "discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used."
                },
                "holding": {
                  "docs": "Holding Registers - Holding registers are the most universal 16-bit register. They may be read and/or written. Modbus *Function Code 3 (Read Holding Registers)* will be used."
                },
                "read": {
                  "docs": "Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used."
                }
              }
            },
            "restore_mode": {
              "default": "DISABLED",
              "key": "Optional",
              "type": "enum",
              "values": {
                "ALWAYS_OFF": null,
                "ALWAYS_ON": null,
                "DISABLED": null,
                "RESTORE_DEFAULT_OFF": null,
                "RESTORE_DEFAULT_ON": null,
                "RESTORE_INVERTED_DEFAULT_OFF": null,
                "RESTORE_INVERTED_DEFAULT_ON": null
              }
            },
            "use_write_multiple": {
              "default": "False",
              "key": "Optional",
              "type": "boolean"
            },
            "write_lambda": {
              "key": "Optional"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA",
            "modbus_controller.ModbusItemBaseSchema",
            "switch._SWITCH_SCHEMA"
          ]
        },
        "type": "schema"
      }
    }
  },
  "modbus_controller.text_sensor": {
    "schemas": {
      "CONFIG_SCHEMA": {
        "schema": {
          "config_vars": {
            "id": {
              "id_type": {
                "class": "modbus_controller::ModbusTextSensor",
                "parents": [
                  "Component",
                  "EntityBase",
                  "modbus_controller::SensorItem",
                  "text_sensor::TextSensor"
                ]
              }
            },
            "raw_encode": {
              "default": "ANSI",
              "docs": "**, enum**: If the response is binary it can\u2019t be published directly. Since a text sensor only publishes strings the binary data can be encoded. Defaults to `ANSI`. Possible encodings are:\n  * `NONE`: Don\u2019t encode data.\n  \n  * `HEXBYTES`:  2 byte hex string. 0x2011 will be sent as \u201c2011\u201d.\n  \n  * `COMMA`: Byte values as integers, delimited by a coma. 0x2011 will be sent as \u201c32,17\u201d.\n  \n  * `ANSI`: Each byte is treated as an `ANSI` character. All control characters are ignored.\n  \n  \n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "ANSI": {
                  "docs": "Each byte is treated as an `ANSI` character. All control characters are ignored."
                },
                "COMMA": {
                  "docs": "Byte values as integers, delimited by a coma. 0x2011 will be sent as \u201c32,17\u201d."
                },
                "HEXBYTES": {
                  "docs": "2 byte hex string. 0x2011 will be sent as \u201c2011\u201d."
                },
                "NONE": {
                  "docs": "Don\u2019t encode data."
                }
              }
            },
            "register_count": {
              "data_type": "positive_int",
              "default": "0",
              "docs": "**, int**: The number of consecutive registers this read request should span or skip in a single command. Default is 1. See [Optimizing modbus communications](https://esphome.io/components/modbus_controller.html#modbus-register-count) for more details.\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "integer"
            },
            "register_type": {
              "docs": "type of the modbus register.\n  * `coil`: Coils are 1-bit registers (on/off values) that are used to control discrete outputs. They may be read and/or written. Modbus *Function Code 1 (Read Coil Status)* will be used.\n  \n  * `discrete_input`: discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used.\n  \n  * `holding`: Holding Registers - Holding registers are the most universal 16-bit register. They may be read and/or written. Modbus *Function Code 3 (Read Holding Registers)* will be used.\n  \n  * `read`: Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used.\n  \n  \n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*",
              "key": "Optional",
              "type": "enum",
              "values": {
                "coil": {
                  "docs": "Coils are 1-bit registers (on/off values) that are used to control discrete outputs. They may be read and/or written. Modbus *Function Code 1 (Read Coil Status)* will be used."
                },
                "custom": null,
                "discrete_input": {
                  "docs": "discrete input register (read only coil) are similar to coils but can only be read. Modbus *Function Code 2 (Read Input Status)* will be used."
                },
                "holding": {
                  "docs": "Holding Registers - Holding registers are the most universal 16-bit register. They may be read and/or written. Modbus *Function Code 3 (Read Holding Registers)* will be used."
                },
                "read": {
                  "docs": "Read Input Registers - registers are 16-bit registers used for input, and may only be read. Modbus *Function Code 4 (Read Input Registers)* will be used."
                }
              }
            },
            "response_size": {
              "default": "2",
              "docs": "Number of bytes of the response.\n\n*See also: [Modbus Controller Text Sensor](https://esphome.io/components/text_sensor/modbus_controller.html#configuration-variables)*"
            }
          },
          "extends": [
            "core.COMPONENT_SCHEMA",
            "modbus_controller.ModbusItemBaseSchema",
            "text_sensor.TEXT_SENSOR_SCHEMA"
          ]
        },
        "type": "schema"
      }
    }
  }
}